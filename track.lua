repeat
    task.wait(4)
until game:IsLoaded(4)

local Workspace = game:GetService('Workspace')
local Terrain = Workspace:WaitForChild('Terrain')
Terrain.WaterReflectance = 0
Terrain.WaterTransparency = 1
Terrain.WaterWaveSize = 0
Terrain.WaterWaveSpeed = 0

local Lighting = game:GetService('Lighting')
Lighting.Brightness = 0
Lighting.GlobalShadows = false
Lighting.FogEnd = 9e100
Lighting.FogStart = 0

sethiddenproperty(Lighting, 'Technology', 2)
sethiddenproperty(Terrain, 'Decoration', false)

local function clearTextures(v)
    if v:IsA('BasePart') and not v:IsA('MeshPart') then
        v.Material = 'Plastic'
        v.Reflectance = 0
    elseif v:IsA('Decal') or v:IsA('Texture') then
        v.Transparency = 1
    elseif v:IsA('ParticleEmitter') or v:IsA('Trail') then
        v.Lifetime = NumberRange.new(0)
    elseif v:IsA('Explosion') then
        v.BlastPressure = 1
        v.BlastRadius = 1
    elseif
        v:IsA('Fire')
        or v:IsA('SpotLight')
        or v:IsA('Smoke')
        or v:IsA('Sparkles')
    then
        v.Enabled = false
    elseif v:IsA('MeshPart') then
        v.Material = 'Plastic'
        v.Reflectance = 0
        v.TextureID = 10385902758728957
    elseif v:IsA('SpecialMesh') then
        v.TextureId = 0
    elseif v:IsA('ShirtGraphic') then
        v.Graphic = 1
    elseif v:IsA('Shirt') or v:IsA('Pants') then
        v[v.ClassName .. 'Template'] = 1
    elseif v.Name == 'Foilage' and v:IsA('Folder') then
        v:Destroy()
    elseif
        string.find(v.Name, 'Tree')
        or string.find(v.Name, 'Water')
        or string.find(v.Name, 'Bush')
        or string.find(v.Name, 'grass')
    then
        task.wait()
        v:Destroy()
    end
end

game:GetService('Lighting'):ClearAllChildren()

for _, v in pairs(Workspace:GetDescendants()) do
    clearTextures(v)
end

Workspace.DescendantAdded:Connect(function(v)
    clearTextures(v)
end)

-- ===================== AUTO TELEPORT =====================
getgenv().AutoTeleportEnabled = true -- B·∫≠t / T·∫Øt
local TARGET_PLACE_ID = 131952481663528
local CHECK_INTERVAL = 5 -- ki·ªÉm tra m·ªói 5 gi√¢y

task.spawn(function()
    while true do
        task.wait(CHECK_INTERVAL)
        if
            getgenv().AutoTeleportEnabled
            and game.PlaceId ~= TARGET_PLACE_ID
        then
            pcall(function()
                game:GetService('TeleportService'):Teleport(
                    TARGET_PLACE_ID,
                    game:GetService('Players').LocalPlayer
                )
            end)
        end
    end
end)
--============= ANTI-AFK (Full Safe + Jump Simulation) =======================
local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local VirtualUser = game:GetService('VirtualUser')
local VirtualInputManager = game:GetService('VirtualInputManager')

-- üõ°Ô∏è Ch·ªëng AFK c∆° b·∫£n b·∫±ng VirtualUser
LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
    task.wait(1)
    VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
end)

-- üß† H√†m t·∫°o kho·∫£ng th·ªùi gian ng·∫´u nhi√™n (¬±30 gi√¢y)
local function randomWait(base)
    local variation = math.random(-30, 30)
    return math.max(60, base + variation)
end

-- ü§∏ Nh·∫£y m√¥ ph·ªèng m·ªói 5 ph√∫t ¬±30s
task.spawn(function()
    while task.wait(randomWait(300)) do
        VirtualUser:CaptureController()
        VirtualUser:SetKeyDown('0x20') -- ph√≠m Space
        task.wait(0.5)
        VirtualUser:SetKeyUp('0x20')
    end
end)

-- üí® M√¥ ph·ªèng nh·∫•n Space th·ª±c b·∫±ng VirtualInputManager (song song)
function AFK()
    while task.wait(randomWait(300)) do
        VirtualInputManager:SendKeyEvent(true, 'Space', false, game)
        task.wait(0.5)
        VirtualInputManager:SendKeyEvent(false, 'Space', false, game)
        print('[Anti-AFK] Jumped using VirtualInputManager.')
    end
end

spawn(AFK)

-- üß© T·∫Øt Idle Tracking g·ªëc c·ªßa game
pcall(function()
    game.ReplicatedStorage.Network['Idle Tracking: Stop Timer']:FireServer()
    local scripts = LocalPlayer.PlayerScripts.Scripts.Core
    scripts['Idle Tracking'].Enabled = false
    scripts['Server Closing'].Enabled = false
end)
local Players = game:GetService('Players')
local player = Players.LocalPlayer

-- ‚öôÔ∏è C·∫•u h√¨nh: B·∫≠t/T·∫Øt t√≠nh nƒÉng xo√° player kh√°c
local KEEP_ONLY_LOCALPLAYER = true

-- üßç‚Äç‚ôÇÔ∏è H√†m xo√° t·∫•t c·∫£ player kh√°c
local function removeOtherPlayers()
    if not KEEP_ONLY_LOCALPLAYER then
        return
    end
    for _, plr in ipairs(Players:GetChildren()) do
        if plr ~= player then
            pcall(function()
                plr:Destroy()
            end)
        end
    end
end

-- üö´ Khi c√≥ player m·ªõi join -> xo√° ngay v√† qu√©t l·∫°i to√†n b·ªô
Players.PlayerAdded:Connect(function(plr)
    if not KEEP_ONLY_LOCALPLAYER then
        return
    end
    if plr ~= player then
        pcall(function()
            plr:Destroy()
        end)
    end
    removeOtherPlayers()
end)

-- üßπ Khi c√≥ player r·ªùi -> ƒë·∫£m b·∫£o danh s√°ch s·∫°ch
Players.PlayerRemoving:Connect(function(_)
    task.defer(removeOtherPlayers)
end)

-- ‚è≥ V√≤ng ki·ªÉm tra li√™n t·ª•c ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng l·ªçt player ·∫©n
task.spawn(function()
    while task.wait(3) do
        removeOtherPlayers()
    end
end)

-- Ch·∫°y l·∫ßn ƒë·∫ßu ti√™n
removeOtherPlayers()

-- üìù Danh s√°ch ƒë∆∞·ªùng d·∫´n th·ªß c√¥ng mu·ªën xo√°
local ManualPathsToDelete = {
    'workspace.GardenCoinShop',
    'workspace.Debris',
    'workspace.Interaction.UpdateItems.WitchesBrewEvent.PotionShelf',
    'workspace.Interaction.UpdateItems.WitchesBrewEvent.WitchesBrewLeaderboard',
    'workspace.Interaction.UpdateItems.WitchesBrewEvent.WitchesBrewPlate',
    'workspace.Interaction.UpdateItems.WitchesBrewEvent.Witch.Broom',
    'workspace.Interaction.UpdateItems.HalloweenMarketEvent.Casket',
    "workspace.Interaction.UpdateItems.HalloweenMarketEvent['Devious Pumpkin']",
    'workspace.Interaction.UpdateItems.HalloweenMarketEvent.HalloweenEloise',
    'workspace.Interaction.UpdateItems.HalloweenMarketEvent.HalloweenLights',
    'workspace.Interaction.UpdateItems.HalloweenMarketEvent.HalloweenPlate',
    'workspace.Interaction.UpdateItems.HalloweenMarketEvent.HalloweenSteven',
    'workspace.Interaction.UpdateItems.HalloweenMarketEvent.Model1',
    'workspace.Interaction.UpdateItems.HalloweenMarketEvent.Model2',
    'workspace.Interaction.UpdateItems.HalloweenMarketEvent.PumpkinLight',
    'workspace.Interaction.UpdateItems.HalloweenMarketEvent.CandyCornSpecialCurrencyUIOverlap',
    'workspace.HalloweenOuter',
    'workspace.FlyBorder',
    'workspace.BlockPartyOuter',
    'workspace.__THINGS.Orbs',
}

-- üåü ·∫®n ph·∫ßn hi·ªÉn th·ªã c·ªßa Part nh∆∞ng gi·ªØ nguy√™n Prompt + th∆∞ m·ª•c con
local function hidePartVisualButKeepContents(part)
    part.Transparency = 1
    part.CastShadow = false
    part.CanCollide = false
    part.CanTouch = false
    part.CanQuery = false

    for _, child in ipairs(part:GetChildren()) do
        if
            child:IsA('SpecialMesh')
            or child:IsA('Decal')
            or child:IsA('MeshPart')
            or child:IsA('UnionOperation')
        then
            child:Destroy()
        end
    end
end

-- üßπ Xo√° ph·∫ßn hi·ªÉn th·ªã folder nh∆∞ng gi·ªØ Prompt
local function clearFolderVisualButKeepPrompt(folder)
    for _, desc in ipairs(folder:GetDescendants()) do
        if desc:IsA('BasePart') then
            local prompt = desc:FindFirstChildWhichIsA('ProximityPrompt')
            if prompt then
                hidePartVisualButKeepContents(desc)
            else
                desc:Destroy()
            end
        elseif
            desc:IsA('MeshPart')
            or desc:IsA('UnionOperation')
            or desc:IsA('Decal')
        then
            desc:Destroy()
        end
    end
end
local Success, Err = pcall(function()
    local Rep = game:GetService('ReplicatedStorage')

    local NotifItem = require(Rep.Library.Client.NotificationCmds).Item
    local UIReward = require(Rep.Library.Client.UI.BuyMultiple)

    -- V√¥ hi·ªáu h√≥a to√†n b·ªô UI th√¥ng b√°o item / reward
    NotifItem.Bottom = function(...) end
    UIReward.Reward = function(...) end
end)

print(Success and '‚úÖ UI Disabled!' or Err)

-- üå≥ Xo√° c√¢y & qu·∫£
local function clearPlantAndFruits(plant)
    clearFolderVisualButKeepPrompt(plant)
    local fruits = plant:FindFirstChild('Fruits')
    if fruits then
        for _, fruit in ipairs(fruits:GetChildren()) do
            clearFolderVisualButKeepPrompt(fruit)
        end
    end
end

-- üßº Xo√° ƒë∆∞·ªùng d·∫´n th·ªß c√¥ng
local function deleteManualPaths()
    for _, path in ipairs(ManualPathsToDelete) do
        local success, target = pcall(function()
            return loadstring('return ' .. path)()
        end)
        if success and target then
            target:Destroy()
        end
    end
end

-- üßπ Xo√° plot ng∆∞·ªùi ch∆°i kh√°c
local function deleteOtherPlayerPlots()
    local plots = workspace:FindFirstChild('__THINGS')
        and workspace.__THINGS:FindFirstChild('Plots')
    if plots then
        for _, plot in ipairs(plots:GetChildren()) do
            local sign = plot:FindFirstChild('Build')
                and plot.Build:FindFirstChild('Sign')
            local isMine = false
            if sign then
                for _, gui in ipairs(sign:GetDescendants()) do
                    if gui:IsA('TextLabel') and gui.Text:find(player.Name) then
                        isMine = true
                        break
                    end
                end
            end
            if not isMine then
                plot:Destroy()
            end
        end
    end
end

-- üßº V√≤ng l·∫∑p d·ªçn map c≈© li√™n t·ª•c
task.spawn(function()
    while task.wait(2) do
        pcall(function()
            for _, obj in ipairs(game:GetService('Lighting'):GetChildren()) do
                obj:Destroy()
            end
            if workspace:FindFirstChild('Debris') then
                for _, obj in ipairs(workspace.Debris:GetChildren()) do
                    obj:Destroy()
                end
            end
            if workspace:FindFirstChild('Terrain') then
                workspace.Terrain:Clear()
            end
            deleteManualPaths()
            for _, farm in workspace:GetChildren() do
                if farm.Name == 'Farm' then
                    for _, subFarm in ipairs(farm:GetChildren()) do
                        if
                            subFarm.Name == 'Farm'
                            and subFarm:FindFirstChild('Important')
                            and subFarm.Important:FindFirstChild('Data')
                            and subFarm.Important.Data:FindFirstChild('Owner')
                        then
                            local isMine = (
                                subFarm.Important.Data.Owner.Value
                                == player.Name
                            )
                            if not isMine then
                                subFarm:Destroy()
                            else
                                local important = subFarm.Important
                                if
                                    important:FindFirstChild('Plants_Physical')
                                then
                                    for _, plant in
                                        ipairs(
                                            important.Plants_Physical:GetChildren()
                                        )
                                    do
                                        clearPlantAndFruits(plant)
                                    end
                                end
                                for _, folderName in ipairs({
                                    'Decorations',
                                    'Fences',
                                    'Cosmetics',
                                }) do
                                    if important:FindFirstChild(folderName) then
                                        for _, obj in
                                            ipairs(
                                                important[folderName]:GetChildren()
                                            )
                                        do
                                            obj:Destroy()
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            deleteOtherPlayerPlots()
            removeOtherPlayers()
        end)
    end
end)
-- HalloweenDashboard Neon Cyberpunk UI
-- Full integrated UI (auto-scale, neon glow, hover, and original logic preserved)

local Rep = game:GetService('ReplicatedStorage')
local Network = require(Rep.Library.Client.Network)
local Directory = require(Rep.Library.Directory)
local Types = require(Rep.Library.Items.Types)
local Save = require(Rep.Library.Client.Save)
local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local TweenService = game:GetService('TweenService')

-- ================ Camera / Resolution ================
local camera = workspace.CurrentCamera
local function GetResolution()
    local size = camera.ViewportSize
    return math.floor(size.X), math.floor(size.Y)
end
local width, height = GetResolution()

-- ================ UI ROOT ================
local gui = Instance.new('ScreenGui')
gui.Name = 'HalloweenDashboard'
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.DisplayOrder = 999

-- parent only after PlayerGui exists
gui.Parent = LocalPlayer:WaitForChild('PlayerGui')

local overlay = Instance.new('Frame', gui)
overlay.Size = UDim2.new(1, 0, 1, 0)
overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
overlay.BackgroundTransparency = 0.6
overlay.BorderSizePixel = 0
overlay.ZIndex = 900

-- Toggle button (neon style)
local toggleButton = Instance.new('TextButton', gui)
local function CalcToggleSize()
    return UDim2.new(
        0,
        math.max(40, math.floor(width * 0.035)),
        0,
        math.max(40, math.floor(height * 0.06))
    )
end
toggleButton.Size = CalcToggleSize()
toggleButton.Position = UDim2.new(0, 10, 0.5, -25)
toggleButton.BackgroundColor3 = Color3.fromRGB(12, 12, 16)
toggleButton.Text = 'üéÉ'
toggleButton.TextColor3 = Color3.fromRGB(200, 255, 255)
toggleButton.Font = Enum.Font.GothamBold
toggleButton.TextSize = 22
toggleButton.ZIndex = 1001

local toggleCorner = Instance.new('UICorner', toggleButton)
toggleCorner.CornerRadius = UDim.new(0, 10)
local toggleStroke = Instance.new('UIStroke', toggleButton)
toggleStroke.Thickness = 2
toggleStroke.Color = Color3.fromRGB(0, 225, 255)

-- Hover effect for toggle
toggleButton.MouseEnter:Connect(function()
    TweenService:Create(
        toggleButton,
        TweenInfo.new(0.18, Enum.EasingStyle.Quad),
        { BackgroundColor3 = Color3.fromRGB(255, 0, 255) }
    ):Play()
    TweenService:Create(
        toggleButton,
        TweenInfo.new(0.18, Enum.EasingStyle.Quad),
        { TextSize = 26 }
    ):Play()
end)
toggleButton.MouseLeave:Connect(function()
    TweenService:Create(
        toggleButton,
        TweenInfo.new(0.25, Enum.EasingStyle.Quad),
        { BackgroundColor3 = Color3.fromRGB(12, 12, 16) }
    ):Play()
    TweenService:Create(
        toggleButton,
        TweenInfo.new(0.25, Enum.EasingStyle.Quad),
        { TextSize = 22 }
    ):Play()
end)

-- Overlay visibility toggle
toggleButton.MouseButton1Click:Connect(function()
    overlay.Visible = not overlay.Visible
end)

-- ================ Main Panel (Auto-scale) ================
local main = Instance.new('Frame', overlay)
main.AnchorPoint = Vector2.new(0.5, 0.5)
main.Position = UDim2.new(0.5, 0, 0.5, 0)
main.Size = UDim2.new(1, 0, 1, 0)
main.BackgroundColor3 = Color3.fromRGB(12, 12, 16)
main.BackgroundTransparency = 0
main.BorderSizePixel = 0
main.ZIndex = 1000

-- Neon corner + stroke + gradient
local mainCorner = Instance.new('UICorner', main)
mainCorner.CornerRadius = UDim.new(0, 12)

local mainStroke = Instance.new('UIStroke', main)
mainStroke.Thickness = 2
mainStroke.Color = Color3.fromRGB(0, 225, 255)
mainStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

local strokeGradient = Instance.new('UIGradient', mainStroke)
strokeGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 255)),
})
strokeGradient.Rotation = 45

local bgGradient = Instance.new('UIGradient', main)
bgGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(20, 0, 40)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 20)),
})
bgGradient.Rotation = 45

-- Glow image behind panel (soft aura)
local glow = Instance.new('ImageLabel', main)
glow.Size = UDim2.new(1.25, 0, 1.25, 0)
glow.Position = UDim2.new(0.5, 0, 0.5, 0)
glow.AnchorPoint = Vector2.new(0.5, 0.5)
glow.BackgroundTransparency = 1
glow.Image = 'rbxassetid://4996891970' -- soft glow image
glow.ImageColor3 = Color3.fromRGB(0, 170, 255)
glow.ImageTransparency = 0.78
glow.ZIndex = 995

-- Title
local title = Instance.new('TextLabel', main)
title.Size = UDim2.new(1, 0, 0, 50)
title.Position = UDim2.new(0, 0, 0, 6)
title.BackgroundTransparency = 1
title.Text = 'üéÉ SUCACHEO HUB üéÉ'
title.Font = Enum.Font.GothamBold
title.TextColor3 = Color3.fromRGB(200, 255, 255)
title.TextSize = 20
title.ZIndex = 1001
title.TextStrokeTransparency = 0.5
title.TextStrokeColor3 = Color3.fromRGB(0, 225, 255)

-- Uptime label
local uptimeLabel = Instance.new('TextLabel', main)
uptimeLabel.Size = UDim2.new(1, 0, 0, 28)
uptimeLabel.Position = UDim2.new(0, 12, 0, 60)
uptimeLabel.BackgroundTransparency = 1
uptimeLabel.Font = Enum.Font.Gotham
uptimeLabel.TextSize = 18
uptimeLabel.TextColor3 = Color3.fromRGB(200, 255, 255)
uptimeLabel.Text = '‚è±Ô∏è Uptime: 00:00:00'
uptimeLabel.ZIndex = 1001
uptimeLabel.TextStrokeTransparency = 0.6

-- Scrolling frame (original layout preserved)
local scroll = Instance.new('ScrollingFrame', main)
scroll.Size = UDim2.new(1, -20, 1, -90)
scroll.Position = UDim2.new(0, 10, 0, 90)
scroll.BackgroundTransparency = 1
scroll.ScrollBarThickness = 6
scroll.CanvasSize = UDim2.new(0, 0, 0, 10)
scroll.ZIndex = 1001

local uiListLayout = Instance.new('UIListLayout', scroll)
uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder
uiListLayout.Padding = UDim.new(0, 6)

-- Labels container
local labels = { currencies = {}, upgrades = {}, crafting = {} }

-- ================ Utility functions (formatting & data) ================
local function formatNumber(n)
    if not n then
        return '0'
    end
    if n >= 1e9 then
        return string.format('%.2fB', n / 1e9)
    elseif n >= 1e6 then
        return string.format('%.2fM', n / 1e6)
    elseif n >= 1e3 then
        return string.format('%.1fK', n / 1e3)
    else
        return tostring(math.floor(n))
    end
end

local function getData()
    return Save.Get() or {}
end

local function getCurrencies()
    local cur = (getData().Inventory and getData().Inventory.Currency) or {}
    local result = {}
    for _, info in pairs(cur) do
        result[info.id] = info._am or 0
    end
    return result
end

-- ================ Build default UI items (Currencies / Upgrades / Crafting) ================
local currencyList = { 'Diamonds', 'HalloweenCoins', 'Diamonds/M' }

-- Header factory
local function MakeHeader(text)
    local h = Instance.new('TextLabel')
    h.Size = UDim2.new(1, 0, 0, 28)
    h.BackgroundTransparency = 1
    h.Font = Enum.Font.GothamBold
    h.TextSize = 15
    h.Text = text
    h.TextColor3 = Color3.fromRGB(0, 225, 255)
    h.TextStrokeTransparency = 0.6
    h.TextStrokeColor3 = Color3.fromRGB(0, 120, 255)
    h.ZIndex = 1002
    h.Parent = scroll
    return h
end

MakeHeader('üí∞ [CURRENCY]')

for _, name in ipairs(currencyList) do
    local lbl = Instance.new('TextLabel')
    lbl.Size = UDim2.new(1, 0, 0, 24)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 15
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.Text = '‚Ä¢ ' .. name .. ' = 0'
    lbl.TextColor3 = Color3.fromRGB(200, 255, 255)
    lbl.TextStrokeTransparency = 0.7
    lbl.ZIndex = 1002
    lbl.Parent = scroll
    labels.currencies[name] = lbl
end

MakeHeader('‚öôÔ∏è [UPGRADES]')

local AllUpgrades = {
    'HalloweenCandyMultiplier',
    'HalloweenTrickOrTreatLuck',
    'HalloweenHugeLuck',
    'HalloweenTitanicLuck',
    'HalloweenMoreDiamonds',
    'HalloweenMoreWitchHats',
    'HalloweenEggLuck',
}

for _, name in ipairs(AllUpgrades) do
    local lbl = Instance.new('TextLabel')
    lbl.Size = UDim2.new(1, 0, 0, 24)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 15
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.Text = '‚Ä¢ ' .. name .. ' = 0/10'
    lbl.TextColor3 = Color3.fromRGB(200, 255, 255)
    lbl.TextStrokeTransparency = 0.7
    lbl.ZIndex = 1002
    lbl.Parent = scroll
    labels.upgrades[name] = lbl
end

MakeHeader('üéÉ [CRAFTING QUEUE]')

local craftLabels = {}

local function updateCraftingUI()
    local allQueue = {}
    -- L·∫•y th√¥ng tin h√†ng ƒë·ª£i ch·∫ø t·∫°o t·ª´ c√°c m√°y ch·∫ø t·∫°o
    for machineId, machineData in pairs(Directory.HalloweenCraftingMachines) do
        local recipes = Network.Invoke(
            'HalloweenCraftingMachine_GetCurrentRecipes',
            machineId
        ) or {}
        local queue = Network.Invoke('HalloweenCraftingMachine_GetQueue') or {}

        for i, recipeData in ipairs(recipes) do
            local recipe = table.clone(recipeData)
            if recipe.Result and recipe.Result.class and recipe.Result.data then
                recipe.Result =
                    Types.From(recipe.Result.class, recipe.Result.data)
            end

            local queuedEntry
            for _, q in ipairs(queue) do
                if q.RecipeIndex == i then
                    queuedEntry = q
                    break
                end
            end

            if queuedEntry and queuedEntry.Remaining > 0 then
                table.insert(
                    allQueue,
                    { Recipe = recipe, Remaining = queuedEntry.Remaining }
                )
            end
        end
    end

    -- Clear old craft labels ordering (we reuse labels table)
    local yCount = 0
    for _, entry in ipairs(allQueue) do
        local recipe = entry.Recipe
        local remaining = entry.Remaining
        if recipe and recipe.Result then
            local itemName = recipe.Result.GetName and recipe.Result:GetName()
                or tostring(recipe.Result)
            local lbl = craftLabels[itemName]

            if not lbl then
                lbl = Instance.new('TextLabel')
                lbl.Size = UDim2.new(1, 0, 0, 24)
                lbl.BackgroundTransparency = 1
                lbl.Font = Enum.Font.Gotham
                lbl.TextSize = 15
                lbl.TextXAlignment = Enum.TextXAlignment.Left
                lbl.TextColor3 = Color3.fromRGB(200, 255, 255)
                lbl.TextStrokeTransparency = 0.7
                lbl.ZIndex = 1002
                lbl.Parent = scroll
                craftLabels[itemName] = lbl
            end

            lbl.Text = '‚Ä¢ '
                .. itemName
                .. ' ‚è≥ Crafting ('
                .. string.format('%.1f', remaining)
                .. 's)'
            yCount = yCount + 1
        end
    end

    -- Update canvas size (UIListLayout handles spacing) but ensure enough space
    local contentSize = uiListLayout.AbsoluteContentSize.Y + 20
    scroll.CanvasSize = UDim2.new(0, 0, 0, contentSize)
end

-- ================ UPDATE UI (DPM, currencies, upgrades, uptime) ================
local startTime = os.clock()
local lastDiamonds = getCurrencies()['Diamonds'] or 0
local dpm = 0
local lastDPMTime = os.clock()

local function updateUI()
    local currencies = getCurrencies()
    local now = os.clock()
    local currentDiamonds = currencies['Diamonds'] or 0

    if now - lastDPMTime >= 60 then
        dpm = currentDiamonds - lastDiamonds
        lastDiamonds = currentDiamonds
        lastDPMTime = now
    end

    for _, name in ipairs(currencyList) do
        local lbl = labels.currencies[name]
        if lbl then
            if name == 'Diamonds/M' then
                lbl.Text =
                    string.format('‚Ä¢ %-15s = %s', name, formatNumber(dpm))
            else
                lbl.Text = string.format(
                    '‚Ä¢ %-15s = %s',
                    name,
                    formatNumber(currencies[name] or 0)
                )
            end
        end
    end

    -- Upgrades
    local up = getData().EventUpgrades or {}
    for _, name in ipairs(AllUpgrades) do
        local lvl = up[name] or 0
        local lbl = labels.upgrades[name]
        if lbl then
            lbl.Text = string.format('‚Ä¢ %-25s = %d/10', name, lvl)
            lbl.TextColor3 = (lvl >= 10) and Color3.fromRGB(0, 255, 128)
                or Color3.fromRGB(200, 255, 255)
        end
    end

    -- Uptime
    local elapsed = os.clock() - startTime
    uptimeLabel.Text = '‚è±Ô∏è Uptime: '
        .. string.format(
            '%02d:%02d:%02d',
            math.floor(elapsed / 3600),
            math.floor((elapsed % 3600) / 60),
            math.floor(elapsed % 60)
        )

    -- Crafting
    updateCraftingUI()
end

-- ================ Loop updater ================
task.spawn(function()
    while task.wait(2) do
        pcall(updateUI)
    end
end)

updateUI()

-- ================ Auto-resize handler ================
camera:GetPropertyChangedSignal('ViewportSize'):Connect(function()
    width, height = GetResolution()
    main.Size =
        UDim2.new(0, math.floor(width * 0.90), 0, math.floor(height * 0.90))
    toggleButton.Size = CalcToggleSize()
end)

-- ================ Auto-resize handler ================
camera:GetPropertyChangedSignal('ViewportSize'):Connect(function()
    width, height = GetResolution()
    main.Size =
        UDim2.new(0, math.floor(width * 0.90), 0, math.floor(height * 0.90))
    toggleButton.Size = CalcToggleSize()
end)

-- ================== SETTINGS ==================
local HOUSE_DELAYS =
    { [1] = 0.1, [2] = 0.1, [3] = 0.3, [4] = 20, [5] = 100, [6] = 200 }
local SIGN_RECHECK_INTERVAL = 10
local EGG_DELAY = 0.5
local MAX_EGG_SLOT = 6
local RANDOM_HOP_DELAY = 300
local MIN_HOP_COOLDOWN = 100
local FAIL_LIMIT = 200

-- ================== SERVICES ==================
local Players = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local HttpService = game:GetService('HttpService')
local TeleportService = game:GetService('TeleportService')
local LocalPlayer = Players.LocalPlayer
local PLOTS = workspace:WaitForChild('__THINGS'):WaitForChild('Plots')
local Plots_Invoke = ReplicatedStorage:WaitForChild('Network')
    :WaitForChild('Plots_Invoke')

-- ================== SERVER HOP ==================
local hoppedServers = {}
local badServers = {}
local lastHopTime = 0

local function safeWaitCooldown()
    local elapsed = os.clock() - lastHopTime
    if elapsed < MIN_HOP_COOLDOWN then
        task.wait(MIN_HOP_COOLDOWN - elapsed)
    end
end

local function hopRandomServer()
    if not getgenv().Config.SERVER_HOP then
        return
    end

    safeWaitCooldown()
    local servers
    local ok = pcall(function()
        servers = HttpService:JSONDecode(
            game:HttpGet(
                'https://games.roblox.com/v1/games/'
                    .. tostring(game.PlaceId)
                    .. '/servers/Public?sortOrder=Asc&limit=100'
            )
        ).data
    end)
    if not ok or not servers or #servers == 0 then
        task.wait(RANDOM_HOP_DELAY)
        TeleportService:Teleport(game.PlaceId, LocalPlayer)
        lastHopTime = os.clock()
        return
    end

    local candidates = {}
    for _, s in ipairs(servers) do
        if
            s.id ~= game.JobId
            and not hoppedServers[s.id]
            and not badServers[s.id]
        then
            table.insert(candidates, s.id)
        end
    end

    if #candidates == 0 then
        hoppedServers = {}
        for _, s in ipairs(servers) do
            if s.id ~= game.JobId and not badServers[s.id] then
                table.insert(candidates, s.id)
            end
        end
        if #candidates == 0 then
            task.wait(RANDOM_HOP_DELAY)
            return hopRandomServer()
        end
    end

    local nextServer = candidates[math.random(#candidates)]
    task.wait(RANDOM_HOP_DELAY)

    local ok = pcall(function()
        TeleportService:TeleportToPlaceInstance(
            game.PlaceId,
            nextServer,
            LocalPlayer
        )
    end)

    lastHopTime = os.clock()
    if ok then
        hoppedServers[nextServer] = true
    else
        hoppedServers[nextServer] = true
        task.wait(MIN_HOP_COOLDOWN)
        hopRandomServer()
    end
end

local function hopServer(reason)
    if not getgenv().Config.SERVER_HOP then
        return
    end
    hopRandomServer()
end

-- ================== DPS LOGIC ==================
local function checkThreshold(thresholds, amountPerSec)
    for _, t in ipairs(thresholds) do
        t = t:gsub(' ', '')
        if t:match('^>') then
            local val = tonumber(t:match('^>(%d+)'))
            if amountPerSec > val then
                return true
            end
        elseif t:match('^<') then
            local val = tonumber(t:match('^<(%d+)'))
            if amountPerSec < val then
                return true
            end
        elseif t:match('~') then
            local minVal, maxVal = t:match('(%d+)~(%d+)')
            minVal, maxVal = tonumber(minVal), tonumber(maxVal)
            if amountPerSec >= minVal and amountPerSec <= maxVal then
                return true
            end
        end
    end
    return false
end

local function decideHousesByDPS(amountPerSec)
    local housesToUnlock = {}
    local eggQtyPerSlot = {}
    for h = 1, MAX_EGG_SLOT do
        local key = 'HOUSE' .. h
        local thresholds = getgenv().Config.DPS_THRESHOLDS[key]
        if thresholds and checkThreshold(thresholds, amountPerSec) then
            housesToUnlock[h] = true
            eggQtyPerSlot[h] = h <= 3 and 3 or 1
        end
    end

    local finalHouses, finalEggQty = {}, {}
    for h = 1, MAX_EGG_SLOT do
        if housesToUnlock[h] then
            table.insert(finalHouses, h)
        end
        finalEggQty[h] = eggQtyPerSlot[h] or 0
    end
    return finalHouses, finalEggQty
end

-- ================== PARSE DPS TH·ª∞C ==================
local function parseDPS(dpsText)
    dpsText = dpsText:gsub('%s', ''):gsub('/sec', '')
    local multiplier = 1
    if dpsText:find('k') then
        multiplier = 1000
        dpsText = dpsText:gsub('k', '')
    elseif dpsText:find('m') then
        multiplier = 1000000
        dpsText = dpsText:gsub('m', '')
    end
    local value = tonumber(dpsText)
    return value and (value * multiplier) or 0
end

-- ================== FIND PLOT & DPS ==================
local function findMyPlotAndAmount()
    local player = game.Players.LocalPlayer
    for _, plot in pairs(PLOTS:GetChildren()) do
        local sign = plot:FindFirstChild('Build')
            and plot.Build:FindFirstChild('Sign')
        if sign then
            for _, gui in pairs(sign:GetDescendants()) do
                if gui:IsA('TextLabel') and gui.Text:find(player.Name) then
                    local coinLabel = sign.Host
                        and sign.Host:FindFirstChild('SurfaceGui')
                        and sign.Host.SurfaceGui:FindFirstChild('Frame')
                        and sign.Host.SurfaceGui.Frame:FindFirstChild(
                            'HalloweenCoins'
                        )
                        and sign.Host.SurfaceGui.Frame.HalloweenCoins:FindFirstChild(
                            'Amount'
                        )
                        and sign.Host.SurfaceGui.Frame.HalloweenCoins.Amount:FindFirstChild(
                            'Amount'
                        )
                    if coinLabel and coinLabel:IsA('TextLabel') then
                        local amountPerSec = parseDPS(coinLabel.Text)
                        return plot, amountPerSec
                    end
                    return plot, 0
                end
            end
        end
    end
    return nil, 0
end

-- ================== HOUSE UNLOCK ==================
local function unlockHouseIfNeeded(plotId, houseNumber, amountPerSec)
    local thresholds = getgenv().Config.DPS_THRESHOLDS['HOUSE' .. houseNumber]
    if thresholds and checkThreshold(thresholds, amountPerSec) then
        pcall(function()
            Plots_Invoke:InvokeServer(plotId, 'PurchaseHouse', houseNumber)
        end)
        return true
    end
    return false
end

-- ================== EGG HANDLER ==================
local lastPurchaseTimes = {}
local activeThreads = {}
local consecutiveFail = { [1] = 0, [2] = 0, [3] = 0 }

local function attemptHopIfNeeded()
    local failSlots = {}
    for i = 1, 3 do
        if consecutiveFail[i] >= FAIL_LIMIT then
            table.insert(failSlots, i)
        end
    end
    if #failSlots >= 2 then
        badServers[game.JobId] = true
        for i = 1, 3 do
            consecutiveFail[i] = 0
        end
        hopServer('House1/2/3 fail limit')
    end
end

local function purchaseEgg(plotId, slot, qty)
    qty = qty or 1
    local ok, result = pcall(function()
        return Plots_Invoke:InvokeServer(plotId, 'PurchaseEgg', slot, qty)
    end)
    lastPurchaseTimes[slot] = os.clock()
    if slot >= 1 and slot <= 3 then
        if ok and result then
            consecutiveFail[slot] = 0
        else
            consecutiveFail[slot] = consecutiveFail[slot] + 1
            attemptHopIfNeeded()
        end
    end
end

local function startEggThread(plotId, slot, delay, qty)
    qty = qty or 1
    local ctrl = { stopFlag = false }
    activeThreads[slot] = ctrl
    task.spawn(function()
        while not ctrl.stopFlag do
            purchaseEgg(plotId, slot, qty)
            task.wait(delay)
        end
    end)
end

local function stopAllThreads()
    for _, ctrl in pairs(activeThreads) do
        ctrl.stopFlag = true
    end
    task.wait(0.05)
    activeThreads = {}
end

-- ================== MAIN LOOP ==================
local lastPlotId, lastHouses = nil, {}
task.spawn(function()
    while true do
        local plot, amount = findMyPlotAndAmount()
        if plot then
            local plotId = tonumber(plot:GetAttribute('ID'))
                or tonumber(plot.Name)
                or 1
            local housesToUnlock, eggQtyPerSlot = decideHousesByDPS(amount)
            local housesJson = HttpService:JSONEncode(housesToUnlock)
            local lastHousesJson = HttpService:JSONEncode(lastHouses)

            if plotId ~= lastPlotId or housesJson ~= lastHousesJson then
                stopAllThreads()
                for _, h in ipairs(housesToUnlock) do
                    unlockHouseIfNeeded(plotId, h, amount)
                    local qty = eggQtyPerSlot[h] or 0
                    if qty > 0 then
                        local delay = HOUSE_DELAYS[h] or EGG_DELAY
                        startEggThread(plotId, h, delay, qty)
                    end
                end
                lastPlotId, lastHouses = plotId, housesToUnlock
            end
        end
        task.wait(SIGN_RECHECK_INTERVAL)
    end
end)

--============= UTILS ==================
local LOG = { verbose = false }
local function log(...)
    if LOG.verbose then
        print(...)
    end
end
local function warnlog(...)
    warn(...)
end

local function SafeInvoke(obj, method, ...)
    local args = { ... }
    for attempt = 1, 5 do
        local ok, result = pcall(function()
            return obj[method](obj, table.unpack(args))
        end)
        if ok then
            return true, result
        end
        task.wait(math.min(0.25 * (2 ^ (attempt - 1)), 2))
    end
    return false, nil
end

local function RF(obj, ...)
    return SafeInvoke(obj, 'InvokeServer', ...)
end
local function EV(obj, ...)
    return SafeInvoke(obj, 'FireServer', ...)
end
--============= UTILS ==================
local LOG = { verbose = false }
local function log(...)
    if LOG.verbose then
        print(...)
    end
end
local function warnlog(...)
    warn(...)
end

local function SafeInvoke(obj, method, ...)
    local args = { ... }
    for attempt = 1, 5 do
        local ok, result = pcall(function()
            return obj[method](obj, table.unpack(args))
        end)
        if ok then
            return true, result
        end
        task.wait(math.min(0.25 * (2 ^ (attempt - 1)), 2))
    end
    return false, nil
end

local function RF(obj, ...)
    return SafeInvoke(obj, 'InvokeServer', ...)
end
local function EV(obj, ...)
    return SafeInvoke(obj, 'FireServer', ...)
end

--============= SERVICES & PLAYER ==================
local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local Rep = game:GetService('ReplicatedStorage')
local Network = Rep:WaitForChild('Network')
local Save = require(Rep.Library.Client.Save)
local HPillarItems = require(Rep.Library.Directory.HPillarItems)

--============= SETTINGS ==================
local UPDATE_INTERVAL = 2.5
local PET_SLOTS = getgenv().Config.plant.PET_SLOTS
local EGG_SLOTS = getgenv().Config.plant.EGG_SLOTS

--============= FUNCTIONS ==================
local function parseRate(text)
    if not text then
        return 0
    end
    text = text:gsub(',', ''):lower()
    local num, suffix = text:match('([%d%.]+)%s*([kmbtq]*)')
    num = tonumber(num)
    if not num then
        return 0
    end
    local mult = { k = 1e3, m = 1e6, b = 1e9, t = 1e12, q = 1e15 }
    return num * (mult[suffix] or 1)
end

local function getCandyMultiplier()
    local upgrades = (Save.Get().EventUpgrades or {})
    local level = upgrades.HalloweenCandyMultiplier or 0
    return 1 + 0.1 * level
end
local CandyMultiplier = getCandyMultiplier()

local function getInventoryPets()
    local data = Save.Get()
    local inv = data and data.Inventory and data.Inventory.HPillar
    local pets, mapByUid = {}, {}
    if inv then
        for uid, info in pairs(inv) do
            local id = info.id
            local base = HPillarItems[id]
            if base then
                local perSec = base.BaseMoneyPerSecond or 0
                local tier = info.pt or 0
                local shiny = info.sh or (info._uq and info._uq.sh)
                local tierMultiplier = { [0] = 1, [1] = 2, [2] = 4, [3] = 6 }
                local shinyMultiplier, sunnyShinyMultiplier = 2, 8
                perSec = perSec * (tierMultiplier[tier] or 1)
                if tier == 3 and shiny then
                    perSec = perSec * sunnyShinyMultiplier / tierMultiplier[3]
                elseif shiny then
                    perSec = perSec * shinyMultiplier
                end
                perSec = perSec * CandyMultiplier
                local entry = {
                    uid = uid,
                    id = id,
                    name = base.DisplayName or id,
                    power = perSec,
                    amount = info._am or 1,
                    tier = tier,
                    shiny = shiny,
                }
                table.insert(pets, entry)
                mapByUid[uid] = entry
            end
        end
    end
    table.sort(pets, function(a, b)
        return a.power > b.power
    end)
    return pets, mapByUid
end

local function getPlayerPlot()
    for _, plot in pairs(workspace.__THINGS.Plots:GetChildren()) do
        local sign = plot:FindFirstChild('Build')
            and plot.Build:FindFirstChild('Sign')
        if sign then
            for _, gui in pairs(sign:GetDescendants()) do
                if gui:IsA('TextLabel') and gui.Text:find(LocalPlayer.Name) then
                    return plot
                end
            end
        end
    end
    return nil
end

local function getPlacedPets(plot)
    local placed = {}
    local pillars =
        plot:WaitForChild('Interactable'):WaitForChild('Pillars'):GetChildren()
    for i, pillar in ipairs(pillars) do
        local base = pillar:FindFirstChild('Base')
        if base then
            local foundModel
            for _, model in pairs(workspace.__DEBRIS:GetChildren()) do
                local part = model:FindFirstChildWhichIsA('BasePart', true)
                if part and (part.Position - base.Position).Magnitude < 3 then
                    foundModel = model
                    break
                end
            end
            if foundModel then
                local uid = foundModel.Name
                local rate
                local petModel = foundModel:FindFirstChild('HalloweenPet')
                    or foundModel
                for _, obj in pairs(petModel:GetDescendants()) do
                    if
                        obj:IsA('TextLabel')
                        and (
                            obj.Text:find('/s')
                            or obj.Name:lower():find('rate')
                        )
                    then
                        rate = parseRate(
                            obj.Text:match('([%d%a%.]+)%s*/%s*s') or obj.Text
                        )
                        break
                    end
                end
                table.insert(
                    placed,
                    { slot = i, model = foundModel, uid = uid, power = rate }
                )
            end
        end
    end
    return placed
end

local function findWeakestPlaced(placed, invMap)
    local weakest, minPower = nil, math.huge
    for _, p in ipairs(placed) do
        local invEntry = invMap[p.uid]
        local power = invEntry and invEntry.power or p.power or 0
        if power < minPower then
            minPower = power
            weakest = { slot = p.slot, uid = p.uid, power = power }
        end
    end
    return weakest, minPower
end

--============= AUTO EGG & PET ==================
local function handleHatchedEggs(plot)
    local placed = getPlacedPets(plot)
    for _, p in ipairs(placed) do
        for _, eggSlot in ipairs(EGG_SLOTS) do
            if p.slot == eggSlot then
                local hasEggText = false
                for _, obj in pairs(p.model:GetDescendants()) do
                    if
                        obj:IsA('TextLabel') and obj.Text:lower():find('egg')
                    then
                        hasEggText = true
                        break
                    end
                end
                if not hasEggText then
                    RF(Network.HalloweenWorld_PickUp, eggSlot)
                    task.wait()
                end
            end
        end
    end
end

local EGG_PRIORITY = {
    Divine = { 'Clown Egg' },
    Mythical = { 'Coffin Egg' },
    Legendary = { 'Reaper Egg', 'Spider Egg' },
    Rare = { 'Bat Egg', 'Grave Egg' },
    Epic = { 'Ghost Egg', 'Cauldron Egg' },
    Basic = { 'Pumpkin Egg' },
}
local EGG_ORDER = { 'Divine', 'Mythical', 'Legendary', 'Rare', 'Epic', 'Basic' }

local function autoPlaceEggs()
    local data = Save.Get()
    local invEggs = data and data.Inventory and data.Inventory.EggHalloween
    if not invEggs then
        return
    end
    local eggs = {}
    for _, eggInfo in pairs(invEggs) do
        eggs[eggInfo.id] = eggInfo._am or 1
    end
    if next(eggs) == nil then
        return
    end
    local plot = getPlayerPlot()
    if not plot then
        return
    end
    local placed = getPlacedPets(plot)
    local occupied = {}
    for _, p in ipairs(placed) do
        occupied[p.slot] = true
    end
    for _, slot in ipairs(EGG_SLOTS) do
        if not occupied[slot] then
            local pick
            for _, rarity in ipairs(EGG_ORDER) do
                for _, eid in ipairs(EGG_PRIORITY[rarity] or {}) do
                    if eggs[eid] and eggs[eid] > 0 then
                        pick = eid
                        eggs[eid] -= 1
                        break
                    end
                end
                if pick then
                    break
                end
            end
            if pick then
                RF(Network.HalloweenWorld_PlaceEgg, slot, pick)
                task.wait(0.1)
            end
        end
    end
end

local function autoEquipPets()
    local plot = getPlayerPlot()
    if not plot then
        return
    end
    local invPets, invMap = getInventoryPets()
    local placed = getPlacedPets(plot)
    local placedBySlot = {}
    for _, p in ipairs(placed) do
        placedBySlot[p.slot] = p
    end
    for _, slot in ipairs(PET_SLOTS) do
        if not placedBySlot[slot] then
            local best = invPets[1]
            if best then
                RF(Network.HalloweenWorld_PlacePet, slot, best.uid)
                task.wait()
                return
            end
        end
    end
    local weakest, weakPower = findWeakestPlaced(placed, invMap)
    local best = invPets[1]
    if weakest and best and best.power > weakPower then
        RF(Network.HalloweenWorld_PickUp, weakest.slot)
        task.wait(0.5)
        RF(Network.HalloweenWorld_PlacePet, weakest.slot, best.uid)
        task.wait()
    end
end

--============= MAIN LOOPS ==================
task.spawn(function()
    while task.wait(UPDATE_INTERVAL) do
        local ok, err = pcall(function()
            local plot = getPlayerPlot()
            if not plot then
                return
            end
            handleHatchedEggs(plot)
            autoPlaceEggs()
            autoEquipPets()
        end)
        if not ok and LOG.verbose then
            warnlog('Loop error:', err)
        end
    end
end)

task.spawn(function()
    while task.wait(5) do
        for i = 1, 10 do
            task.spawn(function()
                RF(Network.HalloweenWorld_Claim, i)
            end)
        end
    end
end)

--==================--
--      SCRIPT      --
--==================--
local HttpService = game:GetService('HttpService')
local player = game.Players.LocalPlayer
local DATA_FILE = player.Name .. '_SEND.json'

repeat
    task.wait()
until game:IsLoaded()

local Config = getgenv().Config
local Network = require(game.ReplicatedStorage.Library.Client.Network)
local Save = require(game.ReplicatedStorage.Library.Client.Save)

--==================--
-- üìÑ LOAD/SAVE
--==================--
local function loadStatus()
    if isfile(DATA_FILE) then
        local s = HttpService:JSONDecode(readfile(DATA_FILE))
        s.SENT_PET_BY_NAME = s.SENT_PET_BY_NAME or {}
        s.SENT_ITEM = s.SENT_ITEM or {}
        s.SENT_DIAMONDS = s.SENT_DIAMONDS or {}
        s.SENT_EGG = s.SENT_EGG or {}
        return s
    else
        local s = {
            SENT_PET_BY_NAME = {},
            SENT_ITEM = {},
            SENT_DIAMONDS = {},
            SENT_EGG = {},
        }
        return s
    end
end

local function saveStatus(data)
    writefile(DATA_FILE, HttpService:JSONEncode(data))
end

local status = loadStatus()

--==================--
-- ‚öôÔ∏è FUNCTIONS
--==================--
local function isPlayerBlocked(list)
    for _, n in ipairs(list) do
        if n == player.Name then
            return true
        end
    end
    return false
end

local function getNextUser(list, sentList)
    for _, n in ipairs(list) do
        if not table.find(sentList, n) then
            return n
        end
    end
    return nil
end

local function countEggs(inv, eggID)
    if not inv or not inv.Egg then
        return 0
    end
    local count = 0
    for _, i in pairs(inv.Egg) do
        if i.id == eggID then
            count += 1
        end
    end
    return count
end
--==================--
-- üéÅ AUTO SEND PET
--==================--
task.spawn(function()
    if isPlayerBlocked(Config.SEND_PET.Usernames) then
        return
    end

    -- N·∫øu FALSE th√¨ chu·∫©n b·ªã b·∫£ng l∆∞u tr√°nh g·ª≠i tr√πng
    if not Config.SEND_PET.SEND_ALL then
        for _, petName in ipairs(Config.SEND_PET.Name_Pet) do
            status.SENT_PET_BY_NAME[petName] = status.SENT_PET_BY_NAME[petName]
                or {}
        end
        saveStatus(status)
    else
        -- N·∫øu TRUE th√¨ d√πng chung 1 b·∫£ng v√≤ng l·∫∑p ng∆∞·ªùi nh·∫≠n
        status.SENT_PET = status.SENT_PET or {}
        saveStatus(status)
    end

    while task.wait(Config.SEND_PET.PetSendInterval or 60) do
        local inv = Save.Get()
            and Save.Get().Inventory
            and Save.Get().Inventory.Pet
        if not inv then
            continue
        end

        -------------------------------------------------------
        -- MODE 1: SEND_ALL = true ‚Üí G·ª≠i m·ªçi con Huge
        -------------------------------------------------------
        if Config.SEND_PET.SEND_ALL then
            local toUser =
                getNextUser(Config.SEND_PET.Usernames, status.SENT_PET)
            if not toUser then
                print('üîÅ Reset v√≤ng g·ª≠i PET (ALL MODE)')
                status.SENT_PET = {}
                saveStatus(status)
                toUser = Config.SEND_PET.Usernames[1]
            end

            for uid, pet in pairs(inv) do
                if pet.id and pet.id:find('Huge') then
                    local ok = pcall(function()
                        return Network.Invoke(
                            'Mailbox: Send',
                            toUser,
                            pet.id,
                            'Pet',
                            uid,
                            pet._am or 1
                        )
                    end)

                    task.wait(0.5)

                    if ok and not Save.Get().Inventory.Pet[uid] then
                        print('üéÅ G·ª≠i HUGE:', pet.id, '‚Üí', toUser)
                        table.insert(status.SENT_PET, toUser)
                        saveStatus(status)
                        break
                    end
                end
            end

        -------------------------------------------------------
        -- MODE 2: SEND_ALL = false ‚Üí Ch·ªâ g·ª≠i ƒë√∫ng Name_Pet
        -------------------------------------------------------
        else
            for _, petName in ipairs(Config.SEND_PET.Name_Pet) do
                local sentList = status.SENT_PET_BY_NAME[petName]

                for uid, pet in pairs(inv) do
                    if pet.id == petName and not table.find(sentList, uid) then
                        local toUser =
                            getNextUser(Config.SEND_PET.Usernames, sentList)
                        if not toUser then
                            print('üîÅ Reset v√≤ng g·ª≠i PET cho', petName)
                            status.SENT_PET_BY_NAME[petName] = {}
                            saveStatus(status)
                            toUser = Config.SEND_PET.Usernames[1]
                            sentList = status.SENT_PET_BY_NAME[petName]
                        end

                        local ok = pcall(function()
                            return Network.Invoke(
                                'Mailbox: Send',
                                toUser,
                                pet.id,
                                'Pet',
                                uid,
                                pet._am or 1
                            )
                        end)

                        task.wait(0.5)

                        if ok and not Save.Get().Inventory.Pet[uid] then
                            print('üéÅ G·ª≠i:', pet.id, '‚Üí', toUser)
                            table.insert(sentList, uid)
                            saveStatus(status)
                            break
                        end
                    end
                end
            end
        end
    end
end)

--==================--
-- üíé AUTO SEND DIAMONDS
--==================--
task.spawn(function()
    if isPlayerBlocked(Config.SEND_DIAMONDS.Usernames) then
        return
    end

    while task.wait(5) do
        local inv = Save.Get()
            and Save.Get().Inventory
            and Save.Get().Inventory.Currency
        if not inv then
            continue
        end

        local diamondsUID, diamondsData
        for uid, d in pairs(inv) do
            if d.id == 'Diamonds' then
                diamondsUID, diamondsData = uid, d
                break
            end
        end
        if not diamondsUID then
            continue
        end

        local before = diamondsData._am or 0
        if before < Config.SEND_DIAMONDS.MinDiamonds then
            continue
        end

        local toUser =
            getNextUser(Config.SEND_DIAMONDS.Usernames, status.SENT_DIAMONDS)
        if not toUser then
            print('üîÅ Reset v√≤ng g·ª≠i DIAMONDS')
            status.SENT_DIAMONDS = {}
            saveStatus(status)
            toUser = Config.SEND_DIAMONDS.Usernames[1]
        end

        local sendAmount = math.floor(before * 0.99)
        local ok = pcall(function()
            return Network.Invoke(
                'Mailbox: Send',
                toUser,
                'Bless',
                'Currency',
                diamondsUID,
                sendAmount
            )
        end)
        task.wait(0.5)

        local after = Save.Get() and Save.Get().Inventory.Currency
        if ok and after[diamondsUID] and after[diamondsUID]._am < before then
            print('üíé Sent', sendAmount, '‚Üí', toUser)
            table.insert(status.SENT_DIAMONDS, toUser)
            saveStatus(status)
        end
    end
end)

--==================--
-- üì¶ AUTO SEND ITEM
--==================--
task.spawn(function()
    if isPlayerBlocked(Config.SEND_ITEM.Usernames) then
        return
    end

    while task.wait(5) do
        local inv = Save.Get() and Save.Get().Inventory
        if not inv then
            continue
        end

        for category, items in pairs(inv) do
            if category ~= 'Pet' and category ~= 'Currency' then
                for uid, item in pairs(items) do
                    local cfg = Config.SEND_ITEM[item.id]
                    if cfg then
                        local toUser = getNextUser(
                            Config.SEND_ITEM.Usernames,
                            status.SENT_ITEM
                        )
                        if not toUser then
                            print('üîÅ Reset v√≤ng g·ª≠i ITEM')
                            status.SENT_ITEM = {}
                            saveStatus(status)
                            toUser = Config.SEND_ITEM.Usernames[1]
                        end

                        local before = item._am or 0
                        local send = math.min(cfg.amount or 1, before)
                        local ok = pcall(function()
                            return Network.Invoke(
                                'Mailbox: Send',
                                toUser,
                                item.id,
                                category,
                                uid,
                                send
                            )
                        end)
                        task.wait(0.3)

                        local after = Save.Get()
                            and Save.Get().Inventory[category]
                        local remain = after and after[uid] and after[uid]._am
                            or 0
                        if ok and remain < before then
                            print(
                                'üì¶ ITEM g·ª≠i:',
                                item.id,
                                'x' .. send,
                                '‚Üí',
                                toUser
                            )
                            table.insert(status.SENT_ITEM, toUser)
                            saveStatus(status)
                        end
                    end
                end
            end
        end
    end
end)

--==================--
-- ü•ö AUTO SEND EGGS
--==================--
task.spawn(function()
    if isPlayerBlocked(Config.SEND_EGGS.Usernames) then
        return
    end

    while task.wait(10) do
        local inv = Save.Get() and Save.Get().Inventory
        if not inv then
            continue
        end

        local eggInv = inv.Egg
        if not eggInv then
            continue
        end

        for uid, egg in pairs(eggInv) do
            if Config.SEND_EGGS[egg.id] then
                local toUser =
                    getNextUser(Config.SEND_EGGS.Usernames, status.SENT_EGG)
                if not toUser then
                    print('üîÅ Reset v√≤ng g·ª≠i EGG')
                    status.SENT_EGG = {}
                    saveStatus(status)
                    toUser = Config.SEND_EGGS.Usernames[1]
                end

                local ok = pcall(function()
                    return Network.Invoke(
                        'Mailbox: Send',
                        toUser,
                        egg.id,
                        'Egg',
                        uid,
                        egg._am or 1
                    )
                end)
                task.wait(0.3)

                local after = Save.Get() and Save.Get().Inventory.Egg
                if ok and not after[uid] then
                    print('ü•ö EGG g·ª≠i:', egg.id, '‚Üí', toUser)
                    table.insert(status.SENT_EGG, toUser)
                    saveStatus(status)
                    break
                end
            end
        end
    end
end)

local Rep = game:GetService('ReplicatedStorage')
local Network = Rep:WaitForChild('Network')
local Save = require(Rep.Library.Client.Save)

local PURCHASE = Network:FindFirstChild('EventUpgrades: Purchase')

-- üéØ Danh s√°ch n√¢ng c·∫•p c√≥ trong game
local AllUpgrades = {
    'HalloweenCandyMultiplier',
    'HalloweenTrickOrTreatLuck',
    'HalloweenHugeLuck',
    'HalloweenTitanicLuck',
    'HalloweenMoreDiamonds',
    'HalloweenMoreWitchHats',
    'HalloweenEggLuck',
}

-- ‚öôÔ∏è ∆Øu ti√™n n√¢ng tr∆∞·ªõc
local Priority = {
    'HalloweenMoreDiamonds',
    'HalloweenMoreWitchHats',
    'HalloweenCandyMultiplier',
}

-- üïê Th·ªùi gian delay gi·ªØa m·ªói l·∫ßn n√¢ng (ƒë·ªÉ tr√°nh spam)
local DELAY = 1.5

-- üîÅ H√†m l·∫•y c·∫•p ƒë·ªô hi·ªán t·∫°i
local function getUpgradeLevel(name)
    local profile = Save.Get()
    local upgrades = profile.EventUpgrades or {}
    return upgrades[name] or 0
end

-- üìà H√†m n√¢ng c·∫•p c·ª• th·ªÉ
local function upgrade(name)
    local current = getUpgradeLevel(name)
    if current >= 10 then
        return false -- ƒë·∫°t gi·ªõi h·∫°n
    end
    local result = PURCHASE:InvokeServer(name)
    if result == true or (type(result) == 'table' and result.success) then
        print('‚úÖ N√¢ng c·∫•p th√†nh c√¥ng:', name, '‚Üí c·∫•p:', current + 1)
    else
        print('‚ùå Kh√¥ng th·ªÉ n√¢ng:', name, '| K·∫øt qu·∫£:', result)
    end
    task.wait(DELAY)
    return true
end

-- üîÅ V√≤ng l·∫∑p ch√≠nh
while task.wait(DELAY) do
    local doneAllPriority = true

    -- 1Ô∏è‚É£ N√¢ng ∆∞u ti√™n
    for _, name in ipairs(Priority) do
        local level = getUpgradeLevel(name)
        if level < 10 then
            doneAllPriority = false
            print('‚öôÔ∏è ƒêang n√¢ng:', name, '(hi·ªán t·∫°i:', level .. ')')
            upgrade(name)
        end
    end

    -- 2Ô∏è‚É£ N·∫øu t·∫•t c·∫£ ∆∞u ti√™n ƒë√£ max th√¨ n√¢ng ng·∫´u nhi√™n ph·∫ßn c√≤n l·∫°i
    if doneAllPriority then
        local others = {}
        for _, name in ipairs(AllUpgrades) do
            if
                not table.find(Priority, name)
                and getUpgradeLevel(name) < 10
            then
                table.insert(others, name)
            end
        end

        if #others > 0 then
            local pick = others[math.random(1, #others)]
            print('üé≤ Random n√¢ng:', pick)
            upgrade(pick)
        else
            print(
                'üèÅ T·∫•t c·∫£ n√¢ng c·∫•p ƒë√£ ƒë·∫°t c·∫•p t·ªëi ƒëa (10)'
            )
            break
        end
    end
end
task.spawn(function()
    local Rep = game:GetService('ReplicatedStorage')
    local Network = require(Rep.Library.Client.Network)
    local Directory = require(Rep.Library.Directory)
    local Types = require(Rep.Library.Items.Types)
    local InventoryCmds = require(Rep.Library.Client.InventoryCmds)
    local Player = game:GetService('Players').LocalPlayer

    -- H√†m l·∫•y t√™n item an to√†n
    local function getItemName(item)
        if type(item) == 'table' then
            if type(item.GetName) == 'function' then
                return item:GetName()
            elseif item.Name then
                return tostring(item.Name)
            else
                return '[Table]'
            end
        else
            return tostring(item)
        end
    end

    -- Ki·ªÉm tra ƒë·ªß nguy√™n li·ªáu
    local function hasIngredients(recipe)
        if not recipe.Ingredients or #recipe.Ingredients == 0 then
            return false
        end

        for _, ing in ipairs(recipe.Ingredients) do
            local amountNeeded = ing.Amount or 1
            local itemClone = ing.Item:Clone()
            if itemClone:IsA('Pet') then
                -- applyPetOptions n·∫øu c·∫ßn
            end
            if itemClone:CountAny() < amountNeeded then
                return false
            end
        end
        return true
    end

    -- Claim craft xong
    local function claimCraft(queuedEntry)
        local success, msg =
            Network.Invoke('HalloweenCraftingMachine_Claim', queuedEntry.UID)
        local resultName = getItemName(queuedEntry.Result)
        if success then
            print('‚úÖ Claimed: ' .. resultName)
        else
            print('‚ùå Failed to claim: ' .. (msg or 'Unknown'))
        end
    end

    -- T·ª± ƒë·ªông craft
    local function autoCraft(machineId, recipeIndex)
        local args = {
            [1] = machineId,
            [2] = recipeIndex,
            [3] = { ['shiny'] = false, ['pt'] = 0 },
        }
        Network.Invoke('HalloweenCraftingMachine_StartCraft', unpack(args))
        print(
            ('‚Üí Sent craft request for recipe #%d on %s'):format(
                recipeIndex,
                machineId
            )
        )
    end

    -- In tr·∫°ng th√°i recipe
    local function printRecipeStatus(recipe, queuedEntry)
        local resultName = getItemName(recipe.Result)
        local status
        if queuedEntry then
            if queuedEntry.Remaining and queuedEntry.Remaining <= 0 then
                status = '‚úÖ Claimable'
            else
                status = '‚è≥ Crafting... ('
                    .. queuedEntry.Remaining
                    .. 's left)'
            end
        else
            status = hasIngredients(recipe) and 'üü¢ Ready to craft'
                or 'üî¥ Missing ingredients'
        end
        print(('  - %s ‚Üí %s'):format(resultName, status))
    end

    while true do
        for machineId, machineData in pairs(Directory.HalloweenCraftingMachines) do
            print(
                '\n=== Machine: '
                    .. machineData.MachineName
                    .. ' (ID: '
                    .. machineId
                    .. ') ==='
            )

            local recipes = Network.Invoke(
                'HalloweenCraftingMachine_GetCurrentRecipes',
                machineId
            ) or {}
            local queue = Network.Invoke('HalloweenCraftingMachine_GetQueue')
                or {}

            -- 1. Claim craft xong
            for _, queuedEntry in ipairs(queue) do
                if (queuedEntry.Remaining or 0) <= 0 then
                    claimCraft(queuedEntry)
                else
                    local name = getItemName(queuedEntry.Result)
                    print(
                        '‚è≥ Still crafting: '
                            .. name
                            .. ' ('
                            .. queuedEntry.Remaining
                            .. 's left)'
                    )
                end
            end

            -- 2. Craft n·∫øu ƒë·ªß nguy√™n li·ªáu
            for i, recipeData in ipairs(recipes) do
                local recipe = table.clone(recipeData)

                if
                    recipe.Result
                    and recipe.Result.class
                    and recipe.Result.data
                then
                    recipe.Result =
                        Types.From(recipe.Result.class, recipe.Result.data)
                end

                if recipe.Ingredients then
                    local newIngredients = {}
                    for _, ing in ipairs(recipe.Ingredients) do
                        if ing.Item and ing.Item.class and ing.Item.data then
                            local realItem =
                                Types.From(ing.Item.class, ing.Item.data)
                            table.insert(
                                newIngredients,
                                { Item = realItem, Amount = ing.Amount }
                            )
                        end
                    end
                    recipe.Ingredients = newIngredients
                end

                -- Ki·ªÉm tra queued
                local queuedEntry = nil
                for _, q in ipairs(queue) do
                    if q.RecipeIndex == i then
                        queuedEntry = q
                        break
                    end
                end

                printRecipeStatus(recipe, queuedEntry)

                -- Craft n·∫øu ƒë·ªß nguy√™n li·ªáu v√† ch∆∞a ƒëang craft
                if not queuedEntry and hasIngredients(recipe) then
                    autoCraft(machineId, i)
                end
            end
        end

        task.wait(5)
    end
end)
while task.wait(60) do
    game:GetService('ReplicatedStorage')
        :WaitForChild('Network')
        :WaitForChild('Mailbox: Claim All')
        :InvokeServer()
end
task.spawn(function()
    -- ==== C·∫§U H√åNH N·ªòI B·ªò ====
    local BaseWait = 0.5 -- th·ªùi gian ch·ªù c∆° b·∫£n
    local PillarCheckDelay = 0.8 -- th·ªùi gian ch·ªù sau khi teleport t·ªõi pillar
    local EggUseCooldown = 600 -- th·ªùi gian ch·ªù sau khi d√πng egg
    local player = game.Players.LocalPlayer
    local ReplicatedStorage = game:GetService('ReplicatedStorage')
    local Network = ReplicatedStorage:WaitForChild('Network')
    local PlayerSave = require(ReplicatedStorage.Library.Client.Save)

    -- State n·ªôi b·ªô
    local CurrentPlotId = nil
    local TeleDone = false
    local PillarScanDone = false
    local CurrentEggPillars = {}
    local pillarsCFrames = {}

    -- ==== H√ÄM H·ªñ TR·ª¢ ====
    local function buildPillarsCFrames(plot)
        if not plot then
            return
        end
        pillarsCFrames = {}
        for _, pillar in ipairs(plot:GetChildren()) do
            if pillar:IsA('BasePart') then
                pillarsCFrames[pillar.Name] = pillar.CFrame
            end
        end
    end

    local function ensurePillarsBuilt()
        if next(pillarsCFrames) then
            return
        end
        local plotFolder = workspace:FindFirstChild('__THINGS')
            and workspace.__THINGS:FindFirstChild('Plots')
        if not plotFolder or not CurrentPlotId then
            return
        end
        local myPlot = plotFolder:FindFirstChild(tostring(CurrentPlotId))
        if myPlot then
            buildPillarsCFrames(myPlot)
        end
    end

    local function teleportToCFrameSafe(cf)
        if not cf then
            return false
        end
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:FindFirstChild('HumanoidRootPart')
            or char:FindFirstChild('Torso')
            or char:FindFirstChild('UpperTorso')
        if not hrp then
            return false
        end
        local target = cf + Vector3.new(0, 3, 0)
        for i = 1, 6 do
            local ok = pcall(function()
                hrp.CFrame = target
            end)
            if ok then
                return true
            end
            task.wait(0.12)
        end
        return false
    end

    local function getItemIdByName(invType, name)
        local inv = PlayerSave.Get().Inventory[invType]
        if not inv then
            return nil
        end
        for uid, data in pairs(inv) do
            if data.id == name then
                return uid
            end
        end
    end

    -- ==== CH·ªú STATE S·∫¥N S√ÄNG ====
    repeat
        task.wait(BaseWait)
    -- C·∫≠p nh·∫≠t CurrentPlotId, TeleDone, PillarScanDone theo c√°ch b·∫°n x√°c ƒë·ªãnh
    until CurrentPlotId and TeleDone and PillarScanDone

    -- ==== LOOP AUTO TELEPORT PILLARS ====
    task.spawn(function()
        local lastSnapshot = nil
        while true do
            if next(CurrentEggPillars) then
                ensurePillarsBuilt()
                local keys = {}
                for k, _ in pairs(CurrentEggPillars) do
                    table.insert(keys, tostring(k))
                end
                table.sort(keys)
                local s = table.concat(keys, ',')
                if s ~= lastSnapshot then
                    lastSnapshot = s
                    for pid, _ in pairs(CurrentEggPillars) do
                        local id = tonumber(pid) or pid
                        local cf = pillarsCFrames[id]
                        if not cf then
                            ensurePillarsBuilt()
                            cf = pillarsCFrames[id]
                        end
                        if cf then
                            teleportToCFrameSafe(cf)
                            task.wait(PillarCheckDelay)
                        end
                    end
                    task.wait(4)
                else
                    task.wait(BaseWait)
                end
            else
                lastSnapshot = nil
                task.wait(BaseWait)
            end
        end
    end)

    -- ==== LOOP AUTO D√ôNG EGG ====
    task.spawn(function()
        while true do
            task.wait(0.5)
            local inv = PlayerSave.Get().Inventory
            local eggHave = false
            for _, data in pairs(inv.EggHalloween or {}) do
                if data.id == 'Coffin Egg' or data.id == 'Reaper Egg' then
                    eggHave = true
                    break
                end
            end

            local used = false
            if eggHave then
                local luckyEggId =
                    getItemIdByName('Consumable', 'Halloween Lucky Egg')
                local trickLuckId = getItemIdByName(
                    'Consumable',
                    'Halloween Trick or Treat Luck'
                )

                if luckyEggId then
                    pcall(function()
                        Network.Consumables_Consume:InvokeServer(luckyEggId, 1)
                    end)
                    used = true
                    task.wait(1)
                end
                if trickLuckId then
                    pcall(function()
                        Network.Consumables_Consume:InvokeServer(trickLuckId, 1)
                    end)
                    used = true
                end
            end

            task.wait(used and EggUseCooldown or 0.5)
        end
    end)
end)
